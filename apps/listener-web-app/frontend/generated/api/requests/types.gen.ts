/**
 * Copyright 2025 Keisuke Tominaga a.k.a soundTricker
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is auto-generated by @hey-api/openapi-ts

export type APIKey = {
    type?: SecuritySchemeType;
    description?: string | null;
    in: APIKeyIn;
    name: string;
    [key: string]: unknown | SecuritySchemeType | APIKeyIn | string;
};

export enum APIKeyIn {
    QUERY = 'query',
    HEADER = 'header',
    COOKIE = 'cookie'
}

export type AgentRunRequest = {
    appName: string;
    sessionId: string;
    newMessage: string;
    streaming?: boolean;
};

/**
 * The auth config sent by tool asking client to collect auth credentials and
 *
 * adk and client will help to fill in the response
 */
export type AuthConfig = {
    authScheme: APIKey | HTTPBase | OAuth2 | OpenIdConnect | HTTPBearer | OpenIdConnectWithConfig;
    rawAuthCredential?: AuthCredential;
    exchangedAuthCredential?: AuthCredential;
    credentialKey?: string | null;
    [key: string]: unknown | AuthCredential;
};

/**
 * Data class representing an authentication credential.
 *
 * To exchange for the actual credential, please use
 * CredentialExchanger.exchange_credential().
 *
 * Examples: API Key Auth
 * AuthCredential(
 * auth_type=AuthCredentialTypes.API_KEY,
 * api_key="1234",
 * )
 *
 * Example: HTTP Auth
 * AuthCredential(
 * auth_type=AuthCredentialTypes.HTTP,
 * http=HttpAuth(
 * scheme="basic",
 * credentials=HttpCredentials(username="user", password="password"),
 * ),
 * )
 *
 * Example: OAuth2 Bearer Token in HTTP Header
 * AuthCredential(
 * auth_type=AuthCredentialTypes.HTTP,
 * http=HttpAuth(
 * scheme="bearer",
 * credentials=HttpCredentials(token="eyAkaknabna...."),
 * ),
 * )
 *
 * Example: OAuth2 Auth with Authorization Code Flow
 * AuthCredential(
 * auth_type=AuthCredentialTypes.OAUTH2,
 * oauth2=OAuth2Auth(
 * client_id="1234",
 * client_secret="secret",
 * ),
 * )
 *
 * Example: OpenID Connect Auth
 * AuthCredential(
 * auth_type=AuthCredentialTypes.OPEN_ID_CONNECT,
 * oauth2=OAuth2Auth(
 * client_id="1234",
 * client_secret="secret",
 * redirect_uri="https://example.com",
 * scopes=["scope1", "scope2"],
 * ),
 * )
 *
 * Example: Auth with resource reference
 * AuthCredential(
 * auth_type=AuthCredentialTypes.API_KEY,
 * resource_ref="projects/1234/locations/us-central1/resources/resource1",
 * )
 */
export type AuthCredential = {
    authType: AuthCredentialTypes;
    resourceRef?: string | null;
    apiKey?: string | null;
    http?: HttpAuth | null;
    serviceAccount?: ServiceAccount | null;
    oauth2?: OAuth2Auth | null;
    [key: string]: unknown | AuthCredentialTypes;
};

/**
 * Represents the type of authentication credential.
 */
export enum AuthCredentialTypes {
    API_KEY = 'apiKey',
    HTTP = 'http',
    OAUTH2 = 'oauth2',
    OPEN_ID_CONNECT = 'openIdConnect',
    SERVICE_ACCOUNT = 'serviceAccount'
}

/**
 * Content blob.
 */
export type Blob = {
    /**
     * Optional. Display name of the blob. Used to provide a label or filename to distinguish blobs. This field is not currently used in the Gemini GenerateContent calls.
     */
    displayName?: string | null;
    /**
     * Required. Raw bytes.
     */
    data?: string | null;
    /**
     * Required. The IANA standard MIME type of the source data.
     */
    mimeType?: string | null;
};

/**
 * Enum representing the broadcast schedule of a listener program.
 */
export enum BroadcastSchedule {
    DAILY = 'daily',
    WEEKLY = 'weekly'
}

/**
 * Result of executing the [ExecutableCode].
 *
 * Always follows a `part` containing the [ExecutableCode].
 */
export type CodeExecutionResult = {
    /**
     * Required. Outcome of the code execution.
     */
    outcome?: Outcome | null;
    /**
     * Optional. Contains stdout when code execution is successful, stderr or other description otherwise.
     */
    output?: string | null;
};

/**
 * Contains the multi-part content of a message.
 */
export type Content = {
    /**
     * List of parts that constitute a single message. Each part may have
     * a different IANA MIME type.
     */
    parts?: Array<Part> | null;
    /**
     * Optional. The producer of the content. Must be either 'user' or
     * 'model'. Useful to set for multi-turn conversations, otherwise can be
     * empty. If role is not specified, SDK will determine the role.
     */
    role?: string | null;
};

/**
 * Represents an event in a conversation between agents and users.
 *
 * It is used to store the content of the conversation, as well as the actions
 * taken by the agents like function calls, etc.
 *
 * Attributes:
 * invocation_id: The invocation ID of the event.
 * author: "user" or the name of the agent, indicating who appended the event
 * to the session.
 * actions: The actions taken by the agent.
 * long_running_tool_ids: The ids of the long running function calls.
 * branch: The branch of the event.
 * id: The unique identifier of the event.
 * timestamp: The timestamp of the event.
 * is_final_response: Whether the event is the final response of the agent.
 * get_function_calls: Returns the function calls in the event.
 */
export type Event = {
    content?: Content | null;
    groundingMetadata?: GroundingMetadata | null;
    partial?: boolean | null;
    turnComplete?: boolean | null;
    errorCode?: string | null;
    errorMessage?: string | null;
    interrupted?: boolean | null;
    customMetadata?: {
    [key: string]: unknown;
} | null;
    usageMetadata?: GenerateContentResponseUsageMetadata | null;
    invocationId?: string;
    author: string;
    actions?: EventActions;
    longRunningToolIds?: Array<(string)> | null;
    branch?: string | null;
    id?: string;
    timestamp?: number;
};

/**
 * Represents the actions attached to an event.
 */
export type EventActions = {
    skipSummarization?: boolean | null;
    stateDelta?: {
        [key: string]: unknown;
    };
    artifactDelta?: {
        [key: string]: (number);
    };
    transferToAgent?: string | null;
    escalate?: boolean | null;
    requestedAuthConfigs?: {
        [key: string]: AuthConfig;
    };
};

/**
 * Code generated by the model that is meant to be executed, and the result returned to the model.
 *
 * Generated when using the [FunctionDeclaration] tool and
 * [FunctionCallingConfig] mode is set to [Mode.CODE].
 */
export type ExecutableCode = {
    /**
     * Required. The code to be executed.
     */
    code?: string | null;
    /**
     * Required. Programming language of the `code`.
     */
    language?: Language | null;
};

/**
 * URI based data.
 */
export type FileData = {
    /**
     * Optional. Display name of the file data. Used to provide a label or filename to distinguish file datas. It is not currently used in the Gemini GenerateContent calls.
     */
    displayName?: string | null;
    /**
     * Required. URI.
     */
    fileUri?: string | null;
    /**
     * Required. The IANA standard MIME type of the source data.
     */
    mimeType?: string | null;
};

/**
 * A function call.
 */
export type FunctionCall = {
    /**
     * The unique id of the function call. If populated, the client to execute the
     * `function_call` and return the response with the matching `id`.
     */
    id?: string | null;
    /**
     * Optional. The function parameters and values in JSON object format. See [FunctionDeclaration.parameters] for parameter details.
     */
    args?: {
    [key: string]: unknown;
} | null;
    /**
     * Required. The name of the function to call. Matches [FunctionDeclaration.name].
     */
    name?: string | null;
};

/**
 * A function response.
 */
export type FunctionResponse = {
    /**
     * Signals that function call continues, and more responses will be returned, turning the function call into a generator. Is only applicable to NON_BLOCKING function calls (see FunctionDeclaration.behavior for details), ignored otherwise. If false, the default, future responses will not be considered. Is only applicable to NON_BLOCKING function calls, is ignored otherwise. If set to false, future responses will not be considered. It is allowed to return empty `response` with `will_continue=False` to signal that the function call is finished.
     */
    willContinue?: boolean | null;
    /**
     * Specifies how the response should be scheduled in the conversation. Only applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to WHEN_IDLE.
     */
    scheduling?: FunctionResponseScheduling | null;
    /**
     * Optional. The id of the function call this response is for. Populated by the client to match the corresponding function call `id`.
     */
    id?: string | null;
    /**
     * Required. The name of the function to call. Matches [FunctionDeclaration.name] and [FunctionCall.name].
     */
    name?: string | null;
    /**
     * Required. The function response in JSON object format. Use "output" key to specify function output and "error" key to specify error details (if any). If "output" and "error" keys are not specified, then whole "response" is treated as function output.
     */
    response?: {
    [key: string]: unknown;
} | null;
};

/**
 * Specifies how the response should be scheduled in the conversation.
 */
export enum FunctionResponseScheduling {
    SCHEDULING_UNSPECIFIED = 'SCHEDULING_UNSPECIFIED',
    SILENT = 'SILENT',
    WHEN_IDLE = 'WHEN_IDLE',
    INTERRUPT = 'INTERRUPT'
}

/**
 * Usage metadata about response(s).
 */
export type GenerateContentResponseUsageMetadata = {
    /**
     * Output only. List of modalities of the cached content in the request input.
     */
    cacheTokensDetails?: Array<ModalityTokenCount> | null;
    /**
     * Output only. Number of tokens in the cached part in the input (the cached content).
     */
    cachedContentTokenCount?: number | null;
    /**
     * Number of tokens in the response(s).
     */
    candidatesTokenCount?: number | null;
    /**
     * Output only. List of modalities that were returned in the response.
     */
    candidatesTokensDetails?: Array<ModalityTokenCount> | null;
    /**
     * Number of tokens in the request. When `cached_content` is set, this is still the total effective prompt size meaning this includes the number of tokens in the cached content.
     */
    promptTokenCount?: number | null;
    /**
     * Output only. List of modalities that were processed in the request input.
     */
    promptTokensDetails?: Array<ModalityTokenCount> | null;
    /**
     * Output only. Number of tokens present in thoughts output.
     */
    thoughtsTokenCount?: number | null;
    /**
     * Output only. Number of tokens present in tool-use prompt(s).
     */
    toolUsePromptTokenCount?: number | null;
    /**
     * Output only. List of modalities that were processed for tool-use request inputs.
     */
    toolUsePromptTokensDetails?: Array<ModalityTokenCount> | null;
    /**
     * Total token count for prompt, response candidates, and tool-use prompts (if present).
     */
    totalTokenCount?: number | null;
    /**
     * Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota.
     */
    trafficType?: TrafficType | null;
};

/**
 * Grounding chunk.
 */
export type GroundingChunk = {
    /**
     * Grounding chunk from context retrieved by the retrieval tools.
     */
    retrievedContext?: GroundingChunkRetrievedContext | null;
    /**
     * Grounding chunk from the web.
     */
    web?: GroundingChunkWeb | null;
};

/**
 * Chunk from context retrieved by the retrieval tools.
 */
export type GroundingChunkRetrievedContext = {
    /**
     * Additional context for the RAG retrieval result. This is only populated when using the RAG retrieval tool.
     */
    ragChunk?: RagChunk | null;
    /**
     * Text of the attribution.
     */
    text?: string | null;
    /**
     * Title of the attribution.
     */
    title?: string | null;
    /**
     * URI reference of the attribution.
     */
    uri?: string | null;
};

/**
 * Chunk from the web.
 */
export type GroundingChunkWeb = {
    /**
     * Domain of the (original) URI.
     */
    domain?: string | null;
    /**
     * Title of the chunk.
     */
    title?: string | null;
    /**
     * URI reference of the chunk.
     */
    uri?: string | null;
};

/**
 * Metadata returned to client when grounding is enabled.
 */
export type GroundingMetadata = {
    /**
     * List of supporting references retrieved from specified grounding source.
     */
    groundingChunks?: Array<GroundingChunk> | null;
    /**
     * Optional. List of grounding support.
     */
    groundingSupports?: Array<GroundingSupport> | null;
    /**
     * Optional. Output only. Retrieval metadata.
     */
    retrievalMetadata?: RetrievalMetadata | null;
    /**
     * Optional. Queries executed by the retrieval tools.
     */
    retrievalQueries?: Array<(string)> | null;
    /**
     * Optional. Google search entry for the following-up web searches.
     */
    searchEntryPoint?: SearchEntryPoint | null;
    /**
     * Optional. Web search queries for the following-up web search.
     */
    webSearchQueries?: Array<(string)> | null;
};

/**
 * Grounding support.
 */
export type GroundingSupport = {
    /**
     * Confidence score of the support references. Ranges from 0 to 1. 1 is the most confident. This list must have the same size as the grounding_chunk_indices.
     */
    confidenceScores?: Array<(number)> | null;
    /**
     * A list of indices (into 'grounding_chunk') specifying the citations associated with the claim. For instance [1,3,4] means that grounding_chunk[1], grounding_chunk[3], grounding_chunk[4] are the retrieved content attributed to the claim.
     */
    groundingChunkIndices?: Array<(number)> | null;
    /**
     * Segment of the content this support belongs to.
     */
    segment?: Segment | null;
};

export type HTTPBase = {
    type?: SecuritySchemeType;
    description?: string | null;
    scheme: string;
    [key: string]: unknown | SecuritySchemeType | string;
};

export type HTTPBearer = {
    type?: SecuritySchemeType;
    description?: string | null;
    scheme?: "bearer";
    bearerFormat?: string | null;
    [key: string]: unknown | SecuritySchemeType | "bearer";
};

export type HTTPValidationError = {
    detail?: Array<ValidationError>;
};

/**
 * The credentials and metadata for HTTP authentication.
 */
export type HttpAuth = {
    scheme: string;
    credentials: HttpCredentials;
    [key: string]: unknown | string | HttpCredentials;
};

/**
 * Represents the secret token value for HTTP authentication, like user name, password, oauth token, etc.
 */
export type HttpCredentials = {
    username?: string | null;
    password?: string | null;
    token?: string | null;
    [key: string]: unknown;
};

/**
 * Required. Programming language of the `code`.
 */
export enum Language {
    LANGUAGE_UNSPECIFIED = 'LANGUAGE_UNSPECIFIED',
    PYTHON = 'PYTHON'
}

/**
 * Schema for creating a Listener.
 *
 * This schema is used for the signup API.
 */
export type ListenerCreateSchema = {
    [key: string]: unknown;
};

/**
 * Schema for ListenerProgramCalendarSegment response.
 */
export type ListenerProgramCalendarSegmentSchema = {
    id?: string | null;
    createdAt?: string | null;
    updatedAt?: string | null;
    /**
     * 番組コーナーのタイトル
     */
    title: string;
    /**
     * 番組コーナーの説明
     */
    description?: string | null;
    /**
     * 番組コーナーの制約条件（例：「定例は除く」「政治的な内容は除く」「AIについては話さない」「最終更新日以降の情報だけ取得する」等）
     */
    constraints?: string | null;
    /**
     * 番組ID
     */
    programId: string;
    /**
     * リスナーID
     */
    listenerId: string;
    /**
     * 番組コーナーの順序
     */
    order: number;
    segmentType?: SegmentType;
    /**
     * このコーナーだけ異なるラジオパーソナリティーが話す場合に設定
     */
    overrideRadioCasts?: Array<(string)>;
    /**
     * 最終読み取りタイムスタンプ
     */
    lastReadTimestamp?: number | null;
    /**
     * 検索開始日 現在日からのオフセット日数
     */
    startOffsetDays: number;
    /**
     * 検索終了日 現在日からのオフセット日数
     */
    endOffsetDays: number;
    /**
     * 予定を取得するGoogle Calendarのcalendar id（基本的にはprimaryを設定）
     */
    calendarId: string;
};

/**
 * Schema for updating a ListenerProgramCalendarSegment.
 */
export type ListenerProgramCalendarSegmentUpdate = {
    /**
     * 番組コーナーのタイトル
     */
    title?: string | null;
    /**
     * 番組コーナーの説明
     */
    description?: string | null;
    /**
     * 番組コーナーの制約条件（例：「定例は除く」「政治的な内容は除く」「AIについては話さない」「最終更新日以降の情報だけ取得する」等）
     */
    constraints?: string | null;
    /**
     * 番組コーナーの順序
     */
    order?: number | null;
    /**
     * このコーナーだけ異なるラジオパーソナリティーが話す場合に設定
     */
    overrideRadioCasts?: Array<(string)> | null;
    segmentType?: SegmentType;
    /**
     * 検索開始日 現在日からのオフセット日数
     */
    startOffsetDays?: number | null;
    /**
     * 検索終了日 現在日からのオフセット日数
     */
    endOffsetDays?: number | null;
    /**
     * 予定を取得するGoogle Calendarのcalendar id（基本的にはprimaryを設定）
     */
    calendarId?: string | null;
};

/**
 * Schema for creating a ListenerProgram.
 */
export type ListenerProgramCreateSchema = {
    /**
     * ラジオ番組のタイトル
     */
    title: string;
    /**
     * ラジオ番組の説明
     */
    description: string;
    /**
     * ラジオ番組の分数（10分、15分、20分、30分から選択）
     */
    programMinutes: number;
    /**
     * 音楽コーナーを作成するかどうか
     */
    insertMusic?: boolean;
    /**
     * ラジオパーソナリティのIDリスト（最大2人まで）
     */
    baseRadioCastIds?: Array<(string)>;
    /**
     * 配信スケジュール（daily:日毎、weekly:週ごと）
     */
    broadcastSchedule?: BroadcastSchedule;
    /**
     * 週ごと配信の場合の配信曜日リスト（monday,tuesday,wednesday,thursday,friday,saturday,sundayのいずれか）
     */
    broadcastDayofweek?: Array<(string)>;
    /**
     * 番組ステータス（draft:下書き、active:アクティブ、pause:一時停止）
     */
    status?: ProgramStatus;
    /**
     * 公開設定（private:非公開、limited:限定公開、publish:公開）
     */
    publishSetting?: PublishSetting;
    /**
     * 限定公開用のプライベートキー（32文字以上、limited設定時に必須）
     */
    privateKey?: string | null;
};

/**
 * Schema for ListenerProgramGmailSegment response.
 */
export type ListenerProgramGmailSegmentSchema = {
    id?: string | null;
    createdAt?: string | null;
    updatedAt?: string | null;
    /**
     * 番組コーナーのタイトル
     */
    title: string;
    /**
     * 番組コーナーの説明
     */
    description?: string | null;
    /**
     * 番組コーナーの制約条件（例：「定例は除く」「政治的な内容は除く」「AIについては話さない」「最終更新日以降の情報だけ取得する」等）
     */
    constraints?: string | null;
    /**
     * 番組ID
     */
    programId: string;
    /**
     * リスナーID
     */
    listenerId: string;
    /**
     * 番組コーナーの順序
     */
    order: number;
    segmentType?: SegmentType;
    /**
     * このコーナーだけ異なるラジオパーソナリティーが話す場合に設定
     */
    overrideRadioCasts?: Array<(string)>;
    /**
     * 最終読み取りタイムスタンプ
     */
    lastReadTimestamp?: number | null;
    /**
     * Gmailのクエリ
     */
    filter: string;
    /**
     * 検索開始日 現在日からのオフセット日数
     */
    startOffsetDays: number;
    /**
     * 検索終了日 現在日からのオフセット日数
     */
    endOffsetDays: number;
};

/**
 * Schema for updating a ListenerProgramGmailSegment.
 */
export type ListenerProgramGmailSegmentUpdate = {
    /**
     * 番組コーナーのタイトル
     */
    title?: string | null;
    /**
     * 番組コーナーの説明
     */
    description?: string | null;
    /**
     * 番組コーナーの制約条件（例：「定例は除く」「政治的な内容は除く」「AIについては話さない」「最終更新日以降の情報だけ取得する」等）
     */
    constraints?: string | null;
    /**
     * 番組コーナーの順序
     */
    order?: number | null;
    /**
     * このコーナーだけ異なるラジオパーソナリティーが話す場合に設定
     */
    overrideRadioCasts?: Array<(string)> | null;
    segmentType?: SegmentType;
    /**
     * Gmailのクエリ
     */
    filter?: string | null;
    /**
     * 検索開始日 現在日からのオフセット日数
     */
    startOffsetDays?: number | null;
    /**
     * 検索終了日 現在日からのオフセット日数
     */
    endOffsetDays?: number | null;
};

/**
 * Schema for ListenerProgramRSSSegment response.
 */
export type ListenerProgramRSSSegmentSchema = {
    id?: string | null;
    createdAt?: string | null;
    updatedAt?: string | null;
    /**
     * 番組コーナーのタイトル
     */
    title: string;
    /**
     * 番組コーナーの説明
     */
    description?: string | null;
    /**
     * 番組コーナーの制約条件（例：「定例は除く」「政治的な内容は除く」「AIについては話さない」「最終更新日以降の情報だけ取得する」等）
     */
    constraints?: string | null;
    /**
     * 番組ID
     */
    programId: string;
    /**
     * リスナーID
     */
    listenerId: string;
    /**
     * 番組コーナーの順序
     */
    order: number;
    segmentType?: SegmentType;
    /**
     * このコーナーだけ異なるラジオパーソナリティーが話す場合に設定
     */
    overrideRadioCasts?: Array<(string)>;
    /**
     * 最終読み取りタイムスタンプ
     */
    lastReadTimestamp?: number | null;
    /**
     * RSS FeedのURL
     */
    feedUrl: string;
};

/**
 * Schema for updating a ListenerProgramRSSSegment.
 */
export type ListenerProgramRSSSegmentUpdate = {
    /**
     * 番組コーナーのタイトル
     */
    title?: string | null;
    /**
     * 番組コーナーの説明
     */
    description?: string | null;
    /**
     * 番組コーナーの制約条件（例：「定例は除く」「政治的な内容は除く」「AIについては話さない」「最終更新日以降の情報だけ取得する」等）
     */
    constraints?: string | null;
    /**
     * 番組コーナーの順序
     */
    order?: number | null;
    /**
     * このコーナーだけ異なるラジオパーソナリティーが話す場合に設定
     */
    overrideRadioCasts?: Array<(string)> | null;
    segmentType?: SegmentType;
    /**
     * RSS FeedのURL
     */
    feedUrl?: string | null;
};

/**
 * Schema for ListenerProgram response.
 */
export type ListenerProgramSchema = {
    id?: string | null;
    createdAt?: string | null;
    updatedAt?: string | null;
    /**
     * ラジオ番組のタイトル
     */
    title: string;
    /**
     * ラジオ番組の説明
     */
    description: string;
    /**
     * リスナーID
     */
    listenerId: string;
    /**
     * ラジオ番組の分数（10分、15分、20分、30分から選択）
     */
    programMinutes: number;
    /**
     * 音楽コーナーを作成するかどうか
     */
    insertMusic: boolean;
    /**
     * ラジオパーソナリティのIDリスト（最大2人まで）
     */
    baseRadioCastIds: Array<(string)>;
    /**
     * 配信スケジュール（日毎、週ごと）
     */
    broadcastSchedule: BroadcastSchedule;
    /**
     * 週ごと配信の場合の配信曜日リスト（monday,tuesday,wednesday,thursday,friday,saturday,sundayのいずれか）
     */
    broadcastDayofweek: Array<(string)>;
    /**
     * 番組ステータス（draft,active,pause）
     */
    status: ProgramStatus;
    /**
     * 公開設定（private:非公開、limited:限定公開、publish:公開）
     */
    publishSetting: PublishSetting;
    /**
     * 限定公開用のプライベートキー（32文字以上）
     */
    privateKey?: string | null;
    /**
     * 公開日時
     */
    publishedAt?: string | null;
    /**
     * 配信回数
     */
    numberOfBroadcast?: number;
};

/**
 * Schema for updating a ListenerProgram.
 */
export type ListenerProgramUpdateSchema = {
    /**
     * ラジオ番組のタイトル
     */
    title?: string | null;
    /**
     * ラジオ番組の説明
     */
    description?: string | null;
    /**
     * ラジオ番組の分数（10分、15分、20分、30分から選択）
     */
    programMinutes?: number | null;
    /**
     * 音楽コーナーを作成するかどうか
     */
    insertMusic?: boolean | null;
    /**
     * ラジオパーソナリティのIDリスト（最大2人まで）
     */
    baseRadioCastIds?: Array<(string)> | null;
    /**
     * 配信スケジュール（daily:日毎、weekly:週ごと）
     */
    broadcastSchedule?: BroadcastSchedule | null;
    /**
     * 週ごと配信の場合の配信曜日リスト（monday,tuesday,wednesday,thursday,friday,saturday,sundayのいずれか）
     */
    broadcastDayofweek?: Array<(string)> | null;
    /**
     * 番組ステータス（draft:下書き、active:アクティブ、pause:一時停止）
     */
    status?: ProgramStatus | null;
    /**
     * 公開設定（private:非公開、limited:限定公開、publish:公開）
     */
    publishSetting?: PublishSetting | null;
    /**
     * 限定公開用のプライベートキー（32文字以上、limited設定時に必須）
     */
    privateKey?: string | null;
    /**
     * 公開日時
     */
    publishedAt?: string | null;
};

/**
 * Schema for ListenerProgramWebSegment response.
 */
export type ListenerProgramWebSegmentSchema = {
    id?: string | null;
    createdAt?: string | null;
    updatedAt?: string | null;
    /**
     * 番組コーナーのタイトル
     */
    title: string;
    /**
     * 番組コーナーの説明
     */
    description?: string | null;
    /**
     * 番組コーナーの制約条件（例：「定例は除く」「政治的な内容は除く」「AIについては話さない」「最終更新日以降の情報だけ取得する」等）
     */
    constraints?: string | null;
    /**
     * 番組ID
     */
    programId: string;
    /**
     * リスナーID
     */
    listenerId: string;
    /**
     * 番組コーナーの順序
     */
    order: number;
    segmentType?: SegmentType;
    /**
     * このコーナーだけ異なるラジオパーソナリティーが話す場合に設定
     */
    overrideRadioCasts?: Array<(string)>;
    /**
     * 最終読み取りタイムスタンプ
     */
    lastReadTimestamp?: number | null;
    /**
     * URLのリスト
     */
    urls?: Array<(string)>;
};

/**
 * Schema for updating a ListenerProgramWebSegment.
 */
export type ListenerProgramWebSegmentUpdate = {
    /**
     * 番組コーナーのタイトル
     */
    title?: string | null;
    /**
     * 番組コーナーの説明
     */
    description?: string | null;
    /**
     * 番組コーナーの制約条件（例：「定例は除く」「政治的な内容は除く」「AIについては話さない」「最終更新日以降の情報だけ取得する」等）
     */
    constraints?: string | null;
    /**
     * 番組コーナーの順序
     */
    order?: number | null;
    /**
     * このコーナーだけ異なるラジオパーソナリティーが話す場合に設定
     */
    overrideRadioCasts?: Array<(string)> | null;
    segmentType?: SegmentType;
    /**
     * URLのリスト
     */
    urls?: Array<(string)> | null;
};

/**
 * Schema for Listener response.
 */
export type ListenerSchema = {
    id: string;
    createdAt?: string | null;
    updatedAt?: string | null;
    email: string;
    displayName?: string | null;
    scopes?: Array<(string)>;
};

/**
 * Server content modalities.
 */
export enum MediaModality {
    MODALITY_UNSPECIFIED = 'MODALITY_UNSPECIFIED',
    TEXT = 'TEXT',
    IMAGE = 'IMAGE',
    VIDEO = 'VIDEO',
    AUDIO = 'AUDIO',
    DOCUMENT = 'DOCUMENT'
}

/**
 * Represents token counting info for a single modality.
 */
export type ModalityTokenCount = {
    /**
     * The modality associated with this token count.
     */
    modality?: MediaModality | null;
    /**
     * Number of tokens.
     */
    tokenCount?: number | null;
};

export type OAuth2 = {
    type?: SecuritySchemeType;
    description?: string | null;
    flows: OAuthFlows;
    [key: string]: unknown | SecuritySchemeType | OAuthFlows;
};

/**
 * Represents credential value and its metadata for a OAuth2 credential.
 */
export type OAuth2Auth = {
    clientId?: string | null;
    clientSecret?: string | null;
    authUri?: string | null;
    state?: string | null;
    redirectUri?: string | null;
    authResponseUri?: string | null;
    authCode?: string | null;
    accessToken?: string | null;
    refreshToken?: string | null;
    expiresAt?: number | null;
    expiresIn?: number | null;
    [key: string]: unknown;
};

export type OAuthFlowAuthorizationCode = {
    refreshUrl?: string | null;
    scopes?: {
        [key: string]: (string);
    };
    authorizationUrl: string;
    tokenUrl: string;
    [key: string]: unknown | string;
};

export type OAuthFlowClientCredentials = {
    refreshUrl?: string | null;
    scopes?: {
        [key: string]: (string);
    };
    tokenUrl: string;
    [key: string]: unknown | string;
};

export type OAuthFlowImplicit = {
    refreshUrl?: string | null;
    scopes?: {
        [key: string]: (string);
    };
    authorizationUrl: string;
    [key: string]: unknown | string;
};

export type OAuthFlowPassword = {
    refreshUrl?: string | null;
    scopes?: {
        [key: string]: (string);
    };
    tokenUrl: string;
    [key: string]: unknown | string;
};

export type OAuthFlows = {
    implicit?: OAuthFlowImplicit | null;
    password?: OAuthFlowPassword | null;
    clientCredentials?: OAuthFlowClientCredentials | null;
    authorizationCode?: OAuthFlowAuthorizationCode | null;
    [key: string]: unknown;
};

export type OpenIdConnect = {
    type?: SecuritySchemeType;
    description?: string | null;
    openIdConnectUrl: string;
    [key: string]: unknown | SecuritySchemeType | string;
};

export type OpenIdConnectWithConfig = {
    type?: SecuritySchemeType;
    description?: string | null;
    authorization_endpoint: string;
    token_endpoint: string;
    userinfo_endpoint?: string | null;
    revocation_endpoint?: string | null;
    token_endpoint_auth_methods_supported?: Array<(string)> | null;
    grant_types_supported?: Array<(string)> | null;
    scopes?: Array<(string)> | null;
    [key: string]: unknown | SecuritySchemeType | string;
};

/**
 * Required. Outcome of the code execution.
 */
export enum Outcome {
    OUTCOME_UNSPECIFIED = 'OUTCOME_UNSPECIFIED',
    OUTCOME_OK = 'OUTCOME_OK',
    OUTCOME_FAILED = 'OUTCOME_FAILED',
    OUTCOME_DEADLINE_EXCEEDED = 'OUTCOME_DEADLINE_EXCEEDED'
}

/**
 * A datatype containing media content.
 *
 * Exactly one field within a Part should be set, representing the specific type
 * of content being conveyed. Using multiple fields within the same `Part`
 * instance is considered invalid.
 */
export type Part = {
    /**
     * Metadata for a given video.
     */
    videoMetadata?: VideoMetadata | null;
    /**
     * Indicates if the part is thought from the model.
     */
    thought?: boolean | null;
    /**
     * Optional. Inlined bytes data.
     */
    inlineData?: Blob | null;
    /**
     * Optional. URI based data.
     */
    fileData?: FileData | null;
    /**
     * An opaque signature for the thought so it can be reused in subsequent requests.
     */
    thoughtSignature?: string | null;
    /**
     * Optional. Result of executing the [ExecutableCode].
     */
    codeExecutionResult?: CodeExecutionResult | null;
    /**
     * Optional. Code generated by the model that is meant to be executed.
     */
    executableCode?: ExecutableCode | null;
    /**
     * Optional. A predicted [FunctionCall] returned from the model that contains a string representing the [FunctionDeclaration.name] with the parameters and their values.
     */
    functionCall?: FunctionCall | null;
    /**
     * Optional. The result output of a [FunctionCall] that contains a string representing the [FunctionDeclaration.name] and a structured JSON object containing any output from the function call. It is used as context to the model.
     */
    functionResponse?: FunctionResponse | null;
    /**
     * Optional. Text part (can be code).
     */
    text?: string | null;
};

/**
 * Schema for creating a ProgramBroadcastHistory.
 */
export type ProgramBroadcastHistoryCreate = {
    /**
     * Number of broadcast
     */
    no: number;
    /**
     * App name
     */
    appName: string;
    /**
     * Listener ID
     */
    listenerId: string;
    /**
     * Session ID
     */
    sessionId: string;
    /**
     * Artifact ID
     */
    artifactId?: string | null;
    /**
     * Status
     */
    status?: ProgramBroadcastHistoryStatus;
};

/**
 * Schema for ProgramBroadcastHistory response.
 */
export type ProgramBroadcastHistorySchema = {
    id?: string | null;
    createdAt?: string | null;
    updatedAt?: string | null;
    no: number;
    appName: string;
    listenerId: string;
    sessionId: string;
    artifactId: string | null;
    status: ProgramBroadcastHistoryStatus;
    newsLetterContents: string | null;
    talkScript: string | null;
    dryRun?: boolean;
};

export enum ProgramBroadcastHistoryStatus {
    PREPARE = 'prepare',
    GENERATING = 'generating',
    SUCCESS = 'success',
    FAILURE = 'failure'
}

/**
 * Schema for updating a ProgramBroadcastHistory.
 */
export type ProgramBroadcastHistoryUpdate = {
    /**
     * Status
     */
    status?: ProgramBroadcastHistoryStatus | null;
};

/**
 * Enum representing the status of a listener program.
 */
export enum ProgramStatus {
    DRAFT = 'draft',
    ACTIVE = 'active',
    PAUSE = 'pause'
}

/**
 * Enum representing the publish setting of a listener program.
 */
export enum PublishSetting {
    PRIVATE = 'private',
    LIMITED = 'limited',
    PUBLISH = 'publish'
}

/**
 * Schema for creating a RadioCast.
 */
export type RadioCastCreateSchema = {
    /**
     * Radio cast name
     */
    name: string;
    role?: RadioCastRole;
    /**
     * For Google GenAI voice
     */
    voiceName: VoiceName;
    /**
     * Personality
     */
    personality: string;
};

export enum RadioCastRole {
    RADIO_PERSONALITY = 'radio personality',
    ASSISTANT = 'assistant',
    GUEST = 'guest'
}

/**
 * Schema for RadioCast response.
 */
export type RadioCastSchema = {
    id?: string | null;
    createdAt?: string | null;
    updatedAt?: string | null;
    name: string;
    listenerId?: string | null;
    role?: RadioCastRole;
    voiceName?: string | null;
    personality?: string | null;
};

/**
 * Schema for updating a RadioCast.
 */
export type RadioCastUpdateSchema = {
    name?: string | null;
    role?: RadioCastRole | null;
    voiceName?: string | null;
    personality?: string | null;
};

/**
 * A RagChunk includes the content of a chunk of a RagFile, and associated metadata.
 */
export type RagChunk = {
    /**
     * If populated, represents where the chunk starts and ends in the document.
     */
    pageSpan?: RagChunkPageSpan | null;
    /**
     * The content of the chunk.
     */
    text?: string | null;
};

/**
 * Represents where the chunk starts and ends in the document.
 */
export type RagChunkPageSpan = {
    /**
     * Page where chunk starts in the document. Inclusive. 1-indexed.
     */
    firstPage?: number | null;
    /**
     * Page where chunk ends in the document. Inclusive. 1-indexed.
     */
    lastPage?: number | null;
};

/**
 * Metadata related to retrieval in the grounding flow.
 */
export type RetrievalMetadata = {
    /**
     * Optional. Score indicating how likely information from Google Search could help answer the prompt. The score is in the range `[0, 1]`, where 0 is the least likely and 1 is the most likely. This score is only populated when Google Search grounding and dynamic retrieval is enabled. It will be compared to the threshold to determine whether to trigger Google Search.
     */
    googleSearchDynamicRetrievalScore?: number | null;
};

/**
 * Google search entry point.
 */
export type SearchEntryPoint = {
    /**
     * Optional. Web content snippet that can be embedded in a web page or an app webview.
     */
    renderedContent?: string | null;
    /**
     * Optional. Base64 encoded JSON representing array of tuple.
     */
    sdkBlob?: string | null;
};

export enum SecuritySchemeType {
    API_KEY = 'apiKey',
    HTTP = 'http',
    OAUTH2 = 'oauth2',
    OPEN_ID_CONNECT = 'openIdConnect'
}

/**
 * Segment of the content.
 */
export type Segment = {
    /**
     * Output only. End index in the given Part, measured in bytes. Offset from the start of the Part, exclusive, starting at zero.
     */
    endIndex?: number | null;
    /**
     * Output only. The index of a Part object within its parent Content object.
     */
    partIndex?: number | null;
    /**
     * Output only. Start index in the given Part, measured in bytes. Offset from the start of the Part, inclusive, starting at zero.
     */
    startIndex?: number | null;
    /**
     * Output only. The text corresponding to the segment from the response.
     */
    text?: string | null;
};

/**
 * Enum representing the types of segments available in a listener program.
 */
export enum SegmentType {
    RSS = 'rss',
    CALENDAR = 'calendar',
    GMAIL = 'gmail',
    WEB = 'web'
}

/**
 * Represents Google Service Account configuration.
 */
export type ServiceAccount = {
    serviceAccountCredential?: ServiceAccountCredential | null;
    scopes: Array<(string)>;
    useDefaultCredential?: boolean | null;
    [key: string]: unknown | string;
};

/**
 * Represents Google Service Account configuration.
 *
 * Attributes:
 * type: The type should be "service_account".
 * project_id: The project ID.
 * private_key_id: The ID of the private key.
 * private_key: The private key.
 * client_email: The client email.
 * client_id: The client ID.
 * auth_uri: The authorization URI.
 * token_uri: The token URI.
 * auth_provider_x509_cert_url: URL for auth provider's X.509 cert.
 * client_x509_cert_url: URL for the client's X.509 cert.
 * universe_domain: The universe domain.
 *
 * Example:
 *
 * config = ServiceAccountCredential(
 * type_="service_account",
 * project_id="your_project_id",
 * private_key_id="your_private_key_id",
 * private_key="-----BEGIN PRIVATE KEY-----...",
 * client_email="...@....iam.gserviceaccount.com",
 * client_id="your_client_id",
 * auth_uri="https://accounts.google.com/o/oauth2/auth",
 * token_uri="https://oauth2.googleapis.com/token",
 * auth_provider_x509_cert_url="https://www.googleapis.com/oauth2/v1/certs",
 * client_x509_cert_url="https://www.googleapis.com/robot/v1/metadata/x509/...",
 * universe_domain="googleapis.com"
 * )
 *
 *
 * config = ServiceAccountConfig.model_construct(**{
 * ...service account config dict
 * })
 */
export type ServiceAccountCredential = {
    type?: string;
    projectId: string;
    privateKeyId: string;
    privateKey: string;
    clientEmail: string;
    clientId: string;
    authUri: string;
    tokenUri: string;
    authProviderX509CertUrl: string;
    clientX509CertUrl: string;
    universeDomain: string;
    [key: string]: unknown | string;
};

/**
 * Represents a series of interactions between a user and agents.
 *
 * Attributes:
 * id: The unique identifier of the session.
 * app_name: The name of the app.
 * user_id: The id of the user.
 * state: The state of the session.
 * events: The events of the session, e.g. user input, model response, function
 * call/response, etc.
 * last_update_time: The last update time of the session.
 */
export type Session = {
    id: string;
    appName: string;
    userId: string;
    state?: {
        [key: string]: unknown;
    };
    events?: Array<Event>;
    lastUpdateTime?: number;
};

/**
 * Output only.
 *
 * Traffic type. This shows whether a request consumes Pay-As-You-Go or
 * Provisioned Throughput quota.
 */
export enum TrafficType {
    TRAFFIC_TYPE_UNSPECIFIED = 'TRAFFIC_TYPE_UNSPECIFIED',
    ON_DEMAND = 'ON_DEMAND',
    PROVISIONED_THROUGHPUT = 'PROVISIONED_THROUGHPUT'
}

export type ValidationError = {
    loc: Array<(string | number)>;
    msg: string;
    type: string;
};

/**
 * Describes how the video in the Part should be used by the model.
 */
export type VideoMetadata = {
    /**
     * The frame rate of the video sent to the model. If not specified, the
     * default value will be 1.0. The fps range is (0.0, 24.0].
     */
    fps?: number | null;
    /**
     * Optional. The end offset of the video.
     */
    endOffset?: string | null;
    /**
     * Optional. The start offset of the video.
     */
    startOffset?: string | null;
};

export enum VoiceName {
    BRIGHT = 'Bright',
    UPBEAT = 'Upbeat',
    INFORMATIVE = 'Informative',
    FIRM = 'Firm',
    EXCITABLE = 'Excitable',
    YOUTHFUL = 'Youthful',
    BREEZY = 'Breezy',
    EASY = 'Easy',
    BREATHY = 'Breathy',
    CLEAR = 'Clear',
    SMOOTH = 'Smooth',
    GRAVELLY = 'Gravelly',
    SOFT = 'Soft',
    EVEN = 'Even',
    MATURE = 'Mature',
    FORWARD = 'Forward',
    FRIENDLY = 'Friendly',
    CASUAL = 'Casual',
    GENTLE = 'Gentle',
    LIVELY = 'Lively',
    KNOWLEDGEABLE = 'Knowledgeable',
    WARM = 'Warm'
}

export type PostApiV1ListenersSignupData = {
    requestBody?: ListenerCreateSchema | null;
};

export type PostApiV1ListenersSignupResponse = ListenerSchema;

export type GetApiV1ListenersMeResponse = ListenerSchema;

export type GetApiV1ListenerProgramsResponse = Array<ListenerProgramSchema>;

export type PostApiV1ListenerProgramsData = {
    requestBody: ListenerProgramCreateSchema;
};

export type PostApiV1ListenerProgramsResponse = ListenerProgramSchema;

export type GetApiV1ListenerProgramsByListenerProgramIdData = {
    listenerProgramId: string;
};

export type GetApiV1ListenerProgramsByListenerProgramIdResponse = ListenerProgramSchema;

export type PutApiV1ListenerProgramsByListenerProgramIdData = {
    listenerProgramId: string;
    requestBody: ListenerProgramUpdateSchema;
};

export type PutApiV1ListenerProgramsByListenerProgramIdResponse = ListenerProgramSchema;

export type DeleteApiV1ListenerProgramsByListenerProgramIdData = {
    listenerProgramId: string;
};

export type DeleteApiV1ListenerProgramsByListenerProgramIdResponse = void;

export type PostApiV1ListenerProgramsByListenerProgramIdGeneratePodcastData = {
    dryRun?: boolean;
    listenerProgramId: string;
};

export type PostApiV1ListenerProgramsByListenerProgramIdGeneratePodcastResponse = unknown;

export type GetApiV1ListenerProgramsByProgramIdSegmentsData = {
    programId: string;
};

export type GetApiV1ListenerProgramsByProgramIdSegmentsResponse = Array<(ListenerProgramRSSSegmentSchema | ListenerProgramCalendarSegmentSchema | ListenerProgramWebSegmentSchema | ListenerProgramGmailSegmentSchema)>;

export type PutApiV1ListenerProgramsByProgramIdSegmentsData = {
    programId: string;
    requestBody: Array<(ListenerProgramRSSSegmentUpdate | ListenerProgramCalendarSegmentUpdate | ListenerProgramWebSegmentUpdate | ListenerProgramGmailSegmentUpdate)>;
};

export type PutApiV1ListenerProgramsByProgramIdSegmentsResponse = Array<(ListenerProgramRSSSegmentSchema | ListenerProgramCalendarSegmentSchema | ListenerProgramWebSegmentSchema | ListenerProgramGmailSegmentSchema)>;

export type GetApiV1ListenerProgramsByProgramIdBroadcastHistoryData = {
    programId: string;
};

export type GetApiV1ListenerProgramsByProgramIdBroadcastHistoryResponse = Array<ProgramBroadcastHistorySchema>;

export type PostApiV1ListenerProgramsByProgramIdBroadcastHistoryData = {
    programId: string;
    requestBody: ProgramBroadcastHistoryCreate;
};

export type PostApiV1ListenerProgramsByProgramIdBroadcastHistoryResponse = ProgramBroadcastHistorySchema;

export type GetApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdData = {
    broadcastHistoryId: string;
    programId: string;
};

export type GetApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdResponse = ProgramBroadcastHistorySchema;

export type PutApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdData = {
    broadcastHistoryId: string;
    programId: string;
    requestBody: ProgramBroadcastHistoryUpdate;
};

export type PutApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdResponse = ProgramBroadcastHistorySchema;

export type DeleteApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdData = {
    broadcastHistoryId: string;
    programId: string;
};

export type DeleteApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdResponse = void;

export type PostApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdGeneratePodcastData = {
    broadcastHistoryId: string;
    dryRun?: boolean;
    programId: string;
};

export type PostApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdGeneratePodcastResponse = ProgramBroadcastHistorySchema;

export type GetApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdAudioData = {
    broadcastHistoryId: string;
    programId: string;
};

export type GetApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdAudioResponse = unknown;

export type PostApiV1RadioCastsData = {
    requestBody: RadioCastCreateSchema;
};

export type PostApiV1RadioCastsResponse = RadioCastSchema;

export type GetApiV1RadioCastsData = {
    radioCastIds?: Array<(string)> | null;
};

export type GetApiV1RadioCastsResponse = Array<RadioCastSchema>;

export type GetApiV1RadioCastsByRadioCastIdData = {
    radioCastId: string;
};

export type GetApiV1RadioCastsByRadioCastIdResponse = RadioCastSchema;

export type PutApiV1RadioCastsByRadioCastIdData = {
    radioCastId: string;
    requestBody: RadioCastUpdateSchema;
};

export type PutApiV1RadioCastsByRadioCastIdResponse = RadioCastSchema;

export type DeleteApiV1RadioCastsByRadioCastIdData = {
    radioCastId: string;
};

export type DeleteApiV1RadioCastsByRadioCastIdResponse = void;

export type GetApiV1PodcastRssByProgramIdData = {
    /**
     * Private key for limited access
     */
    privateKey?: string | null;
    programId: string;
};

export type GetApiV1PodcastRssByProgramIdResponse = unknown;

export type GetApiV1PodcastAudioByProgramIdByBroadcastHistoryIdData = {
    broadcastHistoryId: string;
    /**
     * Private key for limited access
     */
    privateKey?: string | null;
    programId: string;
};

export type GetApiV1PodcastAudioByProgramIdByBroadcastHistoryIdResponse = unknown;

export type GetApiV1GoogleOauth2Data = {
    /**
     * The list of scopes to request
     */
    scopes: Array<(string)>;
};

export type GetApiV1GoogleOauth2Response = string;

export type GetApiV1GoogleOauth2CallbackData = {
    /**
     * The authorization code
     */
    code: string;
    /**
     * The state parameter containing the user ID
     */
    state: string;
};

export type GetApiV1GoogleOauth2CallbackResponse = unknown;

export type PostApiV1AgentsByAppNameSessionData = {
    appName: string;
    requestBody?: {
    [key: string]: unknown;
} | null;
};

export type PostApiV1AgentsByAppNameSessionResponse = Session;

export type GetApiV1AgentsByAppNameSessionBySessionIdData = {
    appName: string;
    sessionId: string;
};

export type GetApiV1AgentsByAppNameSessionBySessionIdResponse = Session;

export type PostApiV1AgentsChatData = {
    requestBody: AgentRunRequest;
};

export type PostApiV1AgentsChatResponse = unknown;

export type GetResponse = unknown;

export type $OpenApiTs = {
    '/api/v1/listeners/signup': {
        post: {
            req: PostApiV1ListenersSignupData;
            res: {
                /**
                 * Successful Response
                 */
                201: ListenerSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/listeners/me': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: ListenerSchema;
            };
        };
    };
    '/api/v1/listener-programs/': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<ListenerProgramSchema>;
            };
        };
        post: {
            req: PostApiV1ListenerProgramsData;
            res: {
                /**
                 * Successful Response
                 */
                201: ListenerProgramSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/listener-programs/{listener_program_id}': {
        get: {
            req: GetApiV1ListenerProgramsByListenerProgramIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: ListenerProgramSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: PutApiV1ListenerProgramsByListenerProgramIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: ListenerProgramSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteApiV1ListenerProgramsByListenerProgramIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/listener-programs/{listener_program_id}/generate-podcast': {
        post: {
            req: PostApiV1ListenerProgramsByListenerProgramIdGeneratePodcastData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/listener-programs/{program_id}/segments': {
        get: {
            req: GetApiV1ListenerProgramsByProgramIdSegmentsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<(ListenerProgramRSSSegmentSchema | ListenerProgramCalendarSegmentSchema | ListenerProgramWebSegmentSchema | ListenerProgramGmailSegmentSchema)>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: PutApiV1ListenerProgramsByProgramIdSegmentsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<(ListenerProgramRSSSegmentSchema | ListenerProgramCalendarSegmentSchema | ListenerProgramWebSegmentSchema | ListenerProgramGmailSegmentSchema)>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/listener-programs/{program_id}/broadcast_history': {
        get: {
            req: GetApiV1ListenerProgramsByProgramIdBroadcastHistoryData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<ProgramBroadcastHistorySchema>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: PostApiV1ListenerProgramsByProgramIdBroadcastHistoryData;
            res: {
                /**
                 * Successful Response
                 */
                201: ProgramBroadcastHistorySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/listener-programs/{program_id}/broadcast_history/{broadcast_history_id}': {
        get: {
            req: GetApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: ProgramBroadcastHistorySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: PutApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: ProgramBroadcastHistorySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/listener-programs/{program_id}/broadcast_history/{broadcast_history_id}/generate-podcast': {
        post: {
            req: PostApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdGeneratePodcastData;
            res: {
                /**
                 * Successful Response
                 */
                200: ProgramBroadcastHistorySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/listener-programs/{program_id}/broadcast_history/{broadcast_history_id}/audio': {
        get: {
            req: GetApiV1ListenerProgramsByProgramIdBroadcastHistoryByBroadcastHistoryIdAudioData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/radio-casts/': {
        post: {
            req: PostApiV1RadioCastsData;
            res: {
                /**
                 * Successful Response
                 */
                201: RadioCastSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetApiV1RadioCastsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<RadioCastSchema>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/radio-casts/{radio_cast_id}': {
        get: {
            req: GetApiV1RadioCastsByRadioCastIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: RadioCastSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        put: {
            req: PutApiV1RadioCastsByRadioCastIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: RadioCastSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteApiV1RadioCastsByRadioCastIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/podcast/rss/{program_id}': {
        get: {
            req: GetApiV1PodcastRssByProgramIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/podcast/audio/{program_id}/{broadcast_history_id}': {
        get: {
            req: GetApiV1PodcastAudioByProgramIdByBroadcastHistoryIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/google-oauth2': {
        get: {
            req: GetApiV1GoogleOauth2Data;
            res: {
                /**
                 * Successful Response
                 */
                200: string;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/google-oauth2/callback': {
        get: {
            req: GetApiV1GoogleOauth2CallbackData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/agents/{app_name}/session': {
        post: {
            req: PostApiV1AgentsByAppNameSessionData;
            res: {
                /**
                 * Successful Response
                 */
                200: Session;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/agents/{app_name}/session/{session_id}': {
        get: {
            req: GetApiV1AgentsByAppNameSessionBySessionIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: Session;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/agents/chat': {
        post: {
            req: PostApiV1AgentsChatData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
            };
        };
    };
};